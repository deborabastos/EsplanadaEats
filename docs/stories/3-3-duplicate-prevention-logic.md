# Story 3.3: Duplicate Prevention Logic

## Status
Draft

## Story
**As a** system,
**I want** to prevent users from submitting multiple ratings for the same restaurant,
**so that** data integrity and reliability of quality averages are maintained.

## Acceptance Criteria
1. System must detect duplicate rating attempts
2. Users must be informed when they have already rated a restaurant
3. Prevention must work even after cache/cookies clearing
4. Form interface must be disabled for users who have already rated
5. Clear message must inform about previous rating
6. System must handle multiple devices from the same user
7. Prevention logic must be implemented on client and validated on server
8. Response time for verification must be minimal (< 1 second)

## Tasks / Subtasks
- [ ] Task 1: Implement duplicate detection system (AC: 1, 8)
  - [ ] Create duplicate detection query system
  - [ ] Implement fast lookup for existing user ratings
  - [ ] Add client-side caching for performance
  - [ ] Ensure response time < 1 second for verification
- [ ] Task 2: Create user notification system (AC: 2, 5)
  - [ ] Design user-friendly duplicate notification messages
  - [ ] Implement clear information about previous rating
  - [ ] Add time-based context (when rating was made)
  - [ ] Create consistent messaging across the application
- [ ] Task 3: Develop robust identification system (AC: 3, 6)
  - [ ] Implement multi-factor user identification
  - [ ] Add device fingerprinting for cross-device detection
  - [ ] Create fallback mechanisms for privacy modes
  - [ ] Ensure prevention works after cache clearing
- [ ] Task 4: Implement form interface controls (AC: 4)
  - [ ] Disable rating form for existing ratings
  - [ ] Show previous rating visually in the interface
  - [ ] Prevent form submission when duplicate detected
  - [ ] Maintain accessibility for disabled form states
- [ ] Task 5: Create server-side validation (AC: 7)
  - [ ] Implement Firebase security rules for duplicate prevention
  - [ ] Add server-side validation as backup to client-side
  - [ ] Create audit logging for rating attempts
  - [ ] Ensure data consistency across concurrent operations

## Dev Notes
This story implements comprehensive duplicate prevention logic that ensures data integrity by preventing multiple ratings from the same user for the same restaurant, using multiple identification methods and both client-side and server-side validation.

## Technical Implementation

### Firebase Data Model
```javascript
// Collection: ratings
{
  id: string,                    // Auto-generated by Firestore
  restaurantId: string,           // Reference to restaurant
  userId: string,                 // User fingerprint from Story 3.1
  quality: number,                // Rating 1-5
  userAgent: string,              // Browser user agent
  timestamp: timestamp,           // Firestore timestamp
  ipAddress: string,              // IP address (if available)
  deviceId?: string,              // Additional device identifier
  session?: string                // Session identifier
}

// Collection: restaurants
{
  id: string,
  name: string,
  photoUrls?: string[],
  averageQuality: number,         // Calculated field
  totalRatings: number,           // Total count of ratings
  createdAt: timestamp,
  updatedAt: timestamp
}
```

### Duplicate Prevention Service
```javascript
// services/DuplicatePreventionService.js
class DuplicatePreventionService {
  constructor(firestore) {
    this.firestore = firestore;
    this.cache = new Map();
    this.cacheExpiry = 5 * 60 * 1000; // 5 minutes
  }

  /**
   * Check if user has already rated this restaurant
   * @param {string} restaurantId
   * @param {string} userId
   * @returns {Promise<{hasRated: boolean, existingRating?: Object}>}
   */
  async checkDuplicateRating(restaurantId, userId) {
    try {
      // Check cache first
      const cacheKey = `${restaurantId}_${userId}`;
      const cachedResult = this.cache.get(cacheKey);

      if (cachedResult && (Date.now() - cachedResult.timestamp) < this.cacheExpiry) {
        return cachedResult.data;
      }

      // Query Firestore for existing rating
      const ratingsRef = this.firestore.collection('ratings');
      const query = ratingsRef
        .where('restaurantId', '==', restaurantId)
        .where('userId', '==', userId)
        .limit(1);

      const snapshot = await query.get();

      if (!snapshot.empty) {
        const existingRating = snapshot.docs[0].data();
        const result = {
          hasRated: true,
          existingRating: {
            id: snapshot.docs[0].id,
            quality: existingRating.quality,
            timestamp: existingRating.timestamp
          }
        };

        // Cache the result
        this.cache.set(cacheKey, {
          data: result,
          timestamp: Date.now()
        });

        return result;
      }

      return { hasRated: false };

    } catch (error) {
      console.error('Error checking duplicate rating:', error);
      // In case of error, allow submission to prevent blocking legitimate ratings
      return { hasRated: false };
    }
  }

  /**
   * Submit rating with duplicate check
   * @param {Object} ratingData
   * @returns {Promise<{success: boolean, message?: string, ratingId?: string}>}
   */
  async submitRating(ratingData) {
    try {
      // First check for duplicates
      const duplicateCheck = await this.checkDuplicateRating(
        ratingData.restaurantId,
        ratingData.userId
      );

      if (duplicateCheck.hasRated) {
        return {
          success: false,
          message: 'Você já avaliou este restaurante anteriormente',
          existingRating: duplicateCheck.existingRating
        };
      }

      // Create rating document
      const ratingDocument = {
        restaurantId: ratingData.restaurantId,
        userId: ratingData.userId,
        quality: ratingData.quality,
        userAgent: navigator.userAgent,
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        ipAddress: await this.getIpAddress(),
        deviceId: this.getDeviceId(),
        session: this.getSessionId()
      };

      // Add to Firestore
      const docRef = await this.firestore.collection('ratings').add(ratingDocument);

      // Update restaurant rating average
      await this.updateRestaurantRating(ratingData.restaurantId);

      // Clear cache for this restaurant-user pair
      const cacheKey = `${ratingData.restaurantId}_${ratingData.userId}`;
      this.cache.delete(cacheKey);

      return {
        success: true,
        ratingId: docRef.id,
        message: 'Avaliação enviada com sucesso!'
      };

    } catch (error) {
      console.error('Error submitting rating:', error);
      return {
        success: false,
        message: 'Erro ao enviar avaliação. Tente novamente.'
      };
    }
  }

  /**
   * Update restaurant's average rating
   * @param {string} restaurantId
   */
  async updateRestaurantRating(restaurantId) {
    try {
      const ratingsRef = this.firestore.collection('ratings');
      const query = ratingsRef.where('restaurantId', '==', restaurantId);

      const snapshot = await query.get();

      if (snapshot.empty) {
        return;
      }

      const ratings = snapshot.docs.map(doc => doc.data());
      const totalRatings = ratings.length;
      const averageQuality = ratings.reduce((sum, rating) => sum + rating.quality, 0) / totalRatings;

      // Update restaurant document
      await this.firestore.collection('restaurants').doc(restaurantId).update({
        averageQuality: Math.round(averageQuality * 100) / 100, // Round to 2 decimal places
        totalRatings: totalRatings,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      });

    } catch (error) {
      console.error('Error updating restaurant rating:', error);
    }
  }

  /**
   * Get client IP address (simplified version)
   * @returns {Promise<string>}
   */
  async getIpAddress() {
    try {
      // Note: In production, you might want to use a server-side endpoint
      // for more reliable IP detection
      const response = await fetch('https://api.ipify.org?format=json');
      const data = await response.json();
      return data.ip;
    } catch (error) {
      console.warn('Could not get IP address:', error);
      return 'unknown';
    }
  }

  /**
   * Get device identifier
   * @returns {string}
   */
  getDeviceId() {
    // Combine multiple factors for device identification
    const screenInfo = `${screen.width}x${screen.height}x${screen.colorDepth}`;
    const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const language = navigator.language;

    // Create a simple hash
    const data = `${screenInfo}|${timeZone}|${language}`;
    return this.simpleHash(data);
  }

  /**
   * Get session identifier
   * @returns {string}
   */
  getSessionId() {
    let sessionId = sessionStorage.getItem('rating_session_id');
    if (!sessionId) {
      sessionId = this.generateUUID();
      sessionStorage.setItem('rating_session_id', sessionId);
    }
    return sessionId;
  }

  /**
   * Simple hash function for device identification
   * @param {string} str
   * @returns {string}
   */
  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16);
  }

  /**
   * Generate UUID v4
   * @returns {string}
   */
  generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * Clear cache entries for a specific user
   * @param {string} userId
   */
  clearUserCache(userId) {
    for (const [key] of this.cache) {
      if (key.endsWith(`_${userId}`)) {
        this.cache.delete(key);
      }
    }
  }
}

// Export for use in rating form
window.DuplicatePreventionService = DuplicatePreventionService;
```

### Integration with Rating Form
```javascript
// Enhanced RatingForm class with duplicate prevention
class RatingForm {
  constructor(container, restaurantId, onRatingSubmit) {
    this.container = container;
    this.restaurantId = restaurantId;
    this.onRatingSubmit = onRatingSubmit;
    this.currentRating = 0;
    this.duplicateService = null;
    this.userId = null;

    this.init();
  }

  async init() {
    await this.initializeServices();
    this.setupStarRating();
    this.setupFormSubmission();
    await this.checkExistingRating();
  }

  async initializeServices() {
    // Initialize user identification
    if (window.UserIdentifier) {
      const identifier = new UserIdentifier();
      this.userId = await identifier.getUserId();
    }

    // Initialize duplicate prevention service
    if (window.firebase && window.firebase.firestore) {
      const firestore = firebase.firestore();
      this.duplicateService = new DuplicatePreventionService(firestore);
    }
  }

  async checkExistingRating() {
    if (!this.duplicateService || !this.userId) {
      return;
    }

    try {
      const result = await this.duplicateService.checkDuplicateRating(
        this.restaurantId,
        this.userId
      );

      if (result.hasRated) {
        this.showExistingRating(result.existingRating);
      }
    } catch (error) {
      console.error('Error checking existing rating:', error);
    }
  }

  showExistingRating(existingRating) {
    // Set the existing rating in the UI
    this.setRating(existingRating.quality);

    // Disable the form
    this.disableForm();

    // Show appropriate message
    const timeAgo = this.getTimeAgo(existingRating.timestamp.toDate());
    this.showFeedback(
      `Você avaliou este restaurante com ${existingRating.quality} estrelas em ${timeAgo}`,
      'info'
    );
  }

  getTimeAgo(date) {
    const now = new Date();
    const diffInMinutes = Math.floor((now - date) / (1000 * 60));

    if (diffInMinutes < 1) return 'menos de um minuto';
    if (diffInMinutes < 60) return `${diffInMinutes} minuto${diffInMinutes > 1 ? 's' : ''} atrás`;

    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) return `${diffInHours} hora${diffInHours > 1 ? 's' : ''} atrás`;

    const diffInDays = Math.floor(diffInHours / 24);
    return `${diffInDays} dia${diffInDays > 1 ? 's' : ''} atrás`;
  }

  async handleFormSubmit(ratingData) {
    if (!this.duplicateService || !this.userId) {
      return {
        success: false,
        message: 'Serviço de avaliação não disponível'
      };
    }

    // Add user ID to rating data
    const completeRatingData = {
      ...ratingData,
      userId: this.userId
    };

    // Submit with duplicate prevention
    return await this.duplicateService.submitRating(completeRatingData);
  }

  // ... rest of the existing RatingForm methods ...
}
```

### Firebase Security Rules
```javascript
// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Ratings collection rules
    match /ratings/{rating} {
      allow create: if request.auth != null &&
                       request.time == request.resource.data.timestamp &&
                       request.resource.data.quality >= 1 &&
                       request.resource.data.quality <= 5 &&
                       request.resource.data.userId == request.auth.uid;

      allow read: if true; // Public read access

      allow update, delete: if false; // Ratings are immutable
    }

    // Restaurants collection rules
    match /restaurants/{restaurant} {
      allow read: if true; // Public read access

      allow create: if request.auth != null &&
                       request.resource.data.name.size() >= 4 &&
                       request.time == request.resource.data.createdAt;

      allow update: if request.auth != null &&
                       request.auth.token.admin == true; // Only admin can update averages

      allow delete: if false; // No deletion allowed
    }
  }
}
```

### Error Handling and Edge Cases
```javascript
// Enhanced error handling in rating form
class RatingFormErrorHandler {
  static handleDuplicateError(error, form) {
    if (error.code === 'already-exists') {
      form.showFeedback('Esta avaliação já existe', 'error');
      form.disableForm();
    } else if (error.code === 'permission-denied') {
      form.showFeedback('Permissão negada para enviar avaliação', 'error');
    } else if (error.code === 'unavailable') {
      form.showFeedback('Serviço indisponível. Tente novamente mais tarde.', 'error');
    } else {
      form.showFeedback('Erro ao enviar avaliação', 'error');
    }
  }

  static handleNetworkError(form) {
    form.showFeedback('Erro de conexão. Verifique sua internet.', 'error');
    form.enableForm();
  }

  static handleTimeoutError(form) {
    form.showFeedback('Operação expirou. Tente novamente.', 'error');
    form.enableForm();
  }
}
```

### Testing
**Testing Checklist:**
- Duplicate detection works for same user on same restaurant
- Cache improves performance for repeated checks
- Form is properly disabled when duplicate detected
- Error messages are clear and helpful
- System handles network timeouts gracefully
- Rating averages are calculated correctly after submission
- Multiple device detection works as expected
- Session persistence works across page reloads
- Security rules prevent unauthorized access
- Performance meets requirements (< 1s response time)

### Dependencies
- Story 3.1: User identification system for userId generation
- Story 3.2: Rating form interface for integration
- Story 0.2: Firebase SDK integration for database operations
- Story 0.4: Security rules for data protection

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-30 | 1.0 | Initial story creation with BMad framework | Dev Agent |

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

## QA Results
*To be populated by QA agent*