# Story 3.3: Duplicate Prevention Logic

## User Story
Como sistema, eu preciso prevenir que usuários enviem múltiplas avaliações para o mesmo restaurante para garantir a integridade dos dados e a confiabilidade das médias de qualidade.

## Acceptance Criteria
- [ ] Sistema deve detectar tentativas de avaliação duplicada
- [ ] Usuários devem ser informados quando já avaliaram um restaurante
- [ ] Prevenção deve funcionar mesmo após limpeza de cache/cookies
- [ ] Interface do formulário deve ser desabilitada para usuários que já avaliaram
- [ ] Mensagem clara deve informar sobre avaliação prévia
- [ ] Sistema deve lidar com múltiplos dispositivos do mesmo usuário
- [ ] Lógica de prevenção deve ser implementada no cliente e validada no servidor
- [ ] Tempo de resposta para verificação deve ser mínimo (< 1 segundo)

## Technical Implementation

### Firebase Data Model
```javascript
// Collection: ratings
{
  id: string,                    // Auto-generated by Firestore
  restaurantId: string,           // Reference to restaurant
  userId: string,                 // User fingerprint from Story 3.1
  quality: number,                // Rating 1-5
  userAgent: string,              // Browser user agent
  timestamp: timestamp,           // Firestore timestamp
  ipAddress: string,              // IP address (if available)
  deviceId?: string,              // Additional device identifier
  session?: string                // Session identifier
}

// Collection: restaurants
{
  id: string,
  name: string,
  photoUrls?: string[],
  averageQuality: number,         // Calculated field
  totalRatings: number,           // Total count of ratings
  createdAt: timestamp,
  updatedAt: timestamp
}
```

### Duplicate Prevention Service
```javascript
// services/DuplicatePreventionService.js
class DuplicatePreventionService {
  constructor(firestore) {
    this.firestore = firestore;
    this.cache = new Map();
    this.cacheExpiry = 5 * 60 * 1000; // 5 minutes
  }

  /**
   * Check if user has already rated this restaurant
   * @param {string} restaurantId
   * @param {string} userId
   * @returns {Promise<{hasRated: boolean, existingRating?: Object}>}
   */
  async checkDuplicateRating(restaurantId, userId) {
    try {
      // Check cache first
      const cacheKey = `${restaurantId}_${userId}`;
      const cachedResult = this.cache.get(cacheKey);

      if (cachedResult && (Date.now() - cachedResult.timestamp) < this.cacheExpiry) {
        return cachedResult.data;
      }

      // Query Firestore for existing rating
      const ratingsRef = this.firestore.collection('ratings');
      const query = ratingsRef
        .where('restaurantId', '==', restaurantId)
        .where('userId', '==', userId)
        .limit(1);

      const snapshot = await query.get();

      if (!snapshot.empty) {
        const existingRating = snapshot.docs[0].data();
        const result = {
          hasRated: true,
          existingRating: {
            id: snapshot.docs[0].id,
            quality: existingRating.quality,
            timestamp: existingRating.timestamp
          }
        };

        // Cache the result
        this.cache.set(cacheKey, {
          data: result,
          timestamp: Date.now()
        });

        return result;
      }

      return { hasRated: false };

    } catch (error) {
      console.error('Error checking duplicate rating:', error);
      // In case of error, allow submission to prevent blocking legitimate ratings
      return { hasRated: false };
    }
  }

  /**
   * Submit rating with duplicate check
   * @param {Object} ratingData
   * @returns {Promise<{success: boolean, message?: string, ratingId?: string}>}
   */
  async submitRating(ratingData) {
    try {
      // First check for duplicates
      const duplicateCheck = await this.checkDuplicateRating(
        ratingData.restaurantId,
        ratingData.userId
      );

      if (duplicateCheck.hasRated) {
        return {
          success: false,
          message: 'Você já avaliou este restaurante anteriormente',
          existingRating: duplicateCheck.existingRating
        };
      }

      // Create rating document
      const ratingDocument = {
        restaurantId: ratingData.restaurantId,
        userId: ratingData.userId,
        quality: ratingData.quality,
        userAgent: navigator.userAgent,
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        ipAddress: await this.getIpAddress(),
        deviceId: this.getDeviceId(),
        session: this.getSessionId()
      };

      // Add to Firestore
      const docRef = await this.firestore.collection('ratings').add(ratingDocument);

      // Update restaurant rating average
      await this.updateRestaurantRating(ratingData.restaurantId);

      // Clear cache for this restaurant-user pair
      const cacheKey = `${ratingData.restaurantId}_${ratingData.userId}`;
      this.cache.delete(cacheKey);

      return {
        success: true,
        ratingId: docRef.id,
        message: 'Avaliação enviada com sucesso!'
      };

    } catch (error) {
      console.error('Error submitting rating:', error);
      return {
        success: false,
        message: 'Erro ao enviar avaliação. Tente novamente.'
      };
    }
  }

  /**
   * Update restaurant's average rating
   * @param {string} restaurantId
   */
  async updateRestaurantRating(restaurantId) {
    try {
      const ratingsRef = this.firestore.collection('ratings');
      const query = ratingsRef.where('restaurantId', '==', restaurantId);

      const snapshot = await query.get();

      if (snapshot.empty) {
        return;
      }

      const ratings = snapshot.docs.map(doc => doc.data());
      const totalRatings = ratings.length;
      const averageQuality = ratings.reduce((sum, rating) => sum + rating.quality, 0) / totalRatings;

      // Update restaurant document
      await this.firestore.collection('restaurants').doc(restaurantId).update({
        averageQuality: Math.round(averageQuality * 100) / 100, // Round to 2 decimal places
        totalRatings: totalRatings,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      });

    } catch (error) {
      console.error('Error updating restaurant rating:', error);
    }
  }

  /**
   * Get client IP address (simplified version)
   * @returns {Promise<string>}
   */
  async getIpAddress() {
    try {
      // Note: In production, you might want to use a server-side endpoint
      // for more reliable IP detection
      const response = await fetch('https://api.ipify.org?format=json');
      const data = await response.json();
      return data.ip;
    } catch (error) {
      console.warn('Could not get IP address:', error);
      return 'unknown';
    }
  }

  /**
   * Get device identifier
   * @returns {string}
   */
  getDeviceId() {
    // Combine multiple factors for device identification
    const screenInfo = `${screen.width}x${screen.height}x${screen.colorDepth}`;
    const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const language = navigator.language;

    // Create a simple hash
    const data = `${screenInfo}|${timeZone}|${language}`;
    return this.simpleHash(data);
  }

  /**
   * Get session identifier
   * @returns {string}
   */
  getSessionId() {
    let sessionId = sessionStorage.getItem('rating_session_id');
    if (!sessionId) {
      sessionId = this.generateUUID();
      sessionStorage.setItem('rating_session_id', sessionId);
    }
    return sessionId;
  }

  /**
   * Simple hash function for device identification
   * @param {string} str
   * @returns {string}
   */
  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16);
  }

  /**
   * Generate UUID v4
   * @returns {string}
   */
  generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * Clear cache entries for a specific user
   * @param {string} userId
   */
  clearUserCache(userId) {
    for (const [key] of this.cache) {
      if (key.endsWith(`_${userId}`)) {
        this.cache.delete(key);
      }
    }
  }
}

// Export for use in rating form
window.DuplicatePreventionService = DuplicatePreventionService;
```

### Integration with Rating Form
```javascript
// Enhanced RatingForm class with duplicate prevention
class RatingForm {
  constructor(container, restaurantId, onRatingSubmit) {
    this.container = container;
    this.restaurantId = restaurantId;
    this.onRatingSubmit = onRatingSubmit;
    this.currentRating = 0;
    this.duplicateService = null;
    this.userId = null;

    this.init();
  }

  async init() {
    await this.initializeServices();
    this.setupStarRating();
    this.setupFormSubmission();
    await this.checkExistingRating();
  }

  async initializeServices() {
    // Initialize user identification
    if (window.UserIdentifier) {
      const identifier = new UserIdentifier();
      this.userId = await identifier.getUserId();
    }

    // Initialize duplicate prevention service
    if (window.firebase && window.firebase.firestore) {
      const firestore = firebase.firestore();
      this.duplicateService = new DuplicatePreventionService(firestore);
    }
  }

  async checkExistingRating() {
    if (!this.duplicateService || !this.userId) {
      return;
    }

    try {
      const result = await this.duplicateService.checkDuplicateRating(
        this.restaurantId,
        this.userId
      );

      if (result.hasRated) {
        this.showExistingRating(result.existingRating);
      }
    } catch (error) {
      console.error('Error checking existing rating:', error);
    }
  }

  showExistingRating(existingRating) {
    // Set the existing rating in the UI
    this.setRating(existingRating.quality);

    // Disable the form
    this.disableForm();

    // Show appropriate message
    const timeAgo = this.getTimeAgo(existingRating.timestamp.toDate());
    this.showFeedback(
      `Você avaliou este restaurante com ${existingRating.quality} estrelas em ${timeAgo}`,
      'info'
    );
  }

  getTimeAgo(date) {
    const now = new Date();
    const diffInMinutes = Math.floor((now - date) / (1000 * 60));

    if (diffInMinutes < 1) return 'menos de um minuto';
    if (diffInMinutes < 60) return `${diffInMinutes} minuto${diffInMinutes > 1 ? 's' : ''} atrás`;

    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) return `${diffInHours} hora${diffInHours > 1 ? 's' : ''} atrás`;

    const diffInDays = Math.floor(diffInHours / 24);
    return `${diffInDays} dia${diffInDays > 1 ? 's' : ''} atrás`;
  }

  async handleFormSubmit(ratingData) {
    if (!this.duplicateService || !this.userId) {
      return {
        success: false,
        message: 'Serviço de avaliação não disponível'
      };
    }

    // Add user ID to rating data
    const completeRatingData = {
      ...ratingData,
      userId: this.userId
    };

    // Submit with duplicate prevention
    return await this.duplicateService.submitRating(completeRatingData);
  }

  // ... rest of the existing RatingForm methods ...
}
```

### Firebase Security Rules
```javascript
// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Ratings collection rules
    match /ratings/{rating} {
      allow create: if request.auth != null &&
                       request.time == request.resource.data.timestamp &&
                       request.resource.data.quality >= 1 &&
                       request.resource.data.quality <= 5 &&
                       request.resource.data.userId == request.auth.uid;

      allow read: if true; // Public read access

      allow update, delete: if false; // Ratings are immutable
    }

    // Restaurants collection rules
    match /restaurants/{restaurant} {
      allow read: if true; // Public read access

      allow create: if request.auth != null &&
                       request.resource.data.name.size() >= 4 &&
                       request.time == request.resource.data.createdAt;

      allow update: if request.auth != null &&
                       request.auth.token.admin == true; // Only admin can update averages

      allow delete: if false; // No deletion allowed
    }
  }
}
```

### Error Handling and Edge Cases
```javascript
// Enhanced error handling in rating form
class RatingFormErrorHandler {
  static handleDuplicateError(error, form) {
    if (error.code === 'already-exists') {
      form.showFeedback('Esta avaliação já existe', 'error');
      form.disableForm();
    } else if (error.code === 'permission-denied') {
      form.showFeedback('Permissão negada para enviar avaliação', 'error');
    } else if (error.code === 'unavailable') {
      form.showFeedback('Serviço indisponível. Tente novamente mais tarde.', 'error');
    } else {
      form.showFeedback('Erro ao enviar avaliação', 'error');
    }
  }

  static handleNetworkError(form) {
    form.showFeedback('Erro de conexão. Verifique sua internet.', 'error');
    form.enableForm();
  }

  static handleTimeoutError(form) {
    form.showFeedback('Operação expirou. Tente novamente.', 'error');
    form.enableForm();
  }
}
```

## Dependencies
- **Story 3.1**: User identification system for userId generation
- **Story 3.2**: Rating form interface for integration
- **Story 0.2**: Firebase SDK integration for database operations
- **Story 0.4**: Security rules for data protection

## Testing Checklist
- [ ] Duplicate detection works for same user on same restaurant
- [ ] Cache improves performance for repeated checks
- [ ] Form is properly disabled when duplicate detected
- [ ] Error messages are clear and helpful
- [ ] System handles network timeouts gracefully
- [ ] Rating averages are calculated correctly after submission
- [ ] Multiple device detection works as expected
- [ ] Session persistence works across page reloads
- [ ] Security rules prevent unauthorized access
- [ ] Performance meets requirements (< 1s response time)

## Notes
- Esta história implementa a lógica crítica de prevenção de avaliações duplicadas
- O sistema utiliza múltiplas camadas de identificação para confiabilidade
- Cache de cliente melhora a experiência do usuário
- A atualização da média é automática e consistente
- As regras de segurança garantem a integridade dos dados
- O sistema foi projetado para ser escalável e performático